####  一、TCP连接过程

​	1.如下图所示，可以看到建立一个TCP连接的过程为（三次握手的过程）:



![img](https://image.fundebug.com/2019-03-21-04.png)

2.为什么会需要三次握手？
一个小故事：古代打仗时，盟军A和B商量去攻打C,先通过通信员沟通攻打的有关事宜。第一次握手：A先写信告诉B，通信员出去后，如果B不回信，A就不知道B有没有收到信息，所以需要第二次握手。此时B的通信员出门了，去告诉A收到了信息，但是如果此时没有第三次握手，B就不知道A有没有收到我已经知道此事的信息，B会怀疑他的通信员是不是被截杀了。于是有了第三次握手：A告诉B，我已经收到了你已经收到消息的消息（嘿嘿，别晕了）。



#### 二. 为什么需要心跳包

1.TCP本身并不提供那么及时的断线检测

 　 断线检测需要轮询发送检测报文，会消耗一定的网络带宽和暂用一定的网络资源。如果把它做成TCP的底层默认功能，那些不需要断线检测的应用程序将会浪费不必要的带宽资源

２. TCP的KeepAlive机制可以用来代替心跳包么？

 　 默认的tcp keep-alive超时时间太长，默认是7200秒，也就是2个小时。socks协议只管转发TCP层具体的数据包，而不会转发TCP协议内的实现细节的包（也做不到），所以，一个应用如果使用了socks代理，那么tcp keep-alive机制就失效了，所以应用要自己有心跳包。

3.网络上有大量的连接缓存设备

 　 举个例子，A客户连着B服务器，但实际上是A->中间的网络设备C->B，如果是A到C断了，实际上B是无法知道的，因为B来说A的连接（就是C）还连着，心跳机制就解决了这个问题



### 三、TCP和UDP的比较



|              | UDP                                        | TCP                                    |
| :----------- | :----------------------------------------- | :------------------------------------- |
| 是否连接     | 无连接                                     | 面向连接                               |
| 是否可靠     | 不可靠传输，不使用流量控制和拥塞控制       | 可靠传输，使用流量控制和拥塞控制       |
| 连接对象个数 | 支持一对一，一对多，多对一和多对多交互通信 | 只能是一对一通信                       |
| 传输方式     | 面向报文                                   | 面向字节流                             |
| 首部开销     | 首部开销小，仅8字节                        | 首部最小20字节，最大60字节             |
| 适用场景     | 适用于实时应用（IP电话、视频会议、直播等） | 适用于要求可靠传输的应用，例如文件传输 |